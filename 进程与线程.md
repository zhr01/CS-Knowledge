## 子进程（subprocess）

在Python中，我们通过标准库中的subprocess包来fork一个子进程，并运行一个外部的程序。

使用subprocess包中的函数创建子进程的时候，要注意:

- 1 在创建子进程之后，父进程是否暂停，并等待子进程运行。
- 2 函数返回什么
- 3 当returncode不为0时，父进程如何处理。

**subprocess.call()**函数：父进程等待子进程完成，返回退出信息

```python
import subprocess
# 我们将程序名(ls)和所带的参数(-l)一起放在一个表中传递给subprocess.call()
rc = subprocess.call(["ls", "-l"])
#可以通过一个shell来解释一整个字符串
out = subprocess.call("ls -l", shell=True)
```

**subprocess.Popen()**函数：主程序不会自动等待子进程完成。我们必须调用对象的**wait()**方法，父进程才会等待 

```python
import subprocess
# 父进程在开启子进程之后并没有等待child的完成，而是直接运行print
child = subprocess.Popen(["ping","-c","5","www.google.com"])
print("parent process")

child = subprocess.Popen(["ping","-c","5","www.google.com"])
child.wait()
print("parent process")
```

### 子进程的文本控制流

我们可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用**subprocess.PIPE**将多个子进程的输入和输出连接在一起，构成**管道**(pipe):

```python
import subprocess
child1 = subprocess.Popen(["ls","-l"], stdout=subprocess.PIPE)
child2 = subprocess.Popen(["wc"], stdin=child1.stdout,stdout=subprocess.PIPE)
out = child2.communicate()
print(out)
```

subprocess.PIPE实际上为文本流提供一个缓存区。child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。

## 信号（signal包）

**siganl.alarm()**：它被用于在**一定时间之后**，向进程自身发送**SIGALRM**信号

```python
import signal
# Define signal handler function
def myHandler(signum, frame):
    print("Now, it's the time")
    exit()

# register signal.SIGALRM's handler 
signal.signal(signal.SIGALRM, myHandler)
signal.alarm(5)
while True:
    print('not yet')
```



## 多线程与同步（threading包）

### 1、多线程售票以及同步

```python
# A program to simulate selling tickets in multi-thread way
# Written by Vamei

import threading
import time
import os

# This function could be any function to do other chores.
def doChore():
    time.sleep(0.5)

# Function for each thread
def booth(tid):
    global i
    global lock
    while True:
        lock.acquire()                # Lock; or wait if other thread is holding the lock
        if i != 0:
            i = i - 1                 # Sell tickets
            print(tid,':now left:',i) # Tickets left
            doChore()                 # Other critical operations
        else:
            print("Thread_id",tid," No more tickets")
            os._exit(0)              # Exit the whole process immediately
        lock.release()               # Unblock
        doChore()                    # Non-critical operations

# Start of the main function
i    = 100                           # Available ticket number 
lock = threading.Lock()              # Lock (i.e., mutex)

# Start 10 threads
for k in range(10):
    new_thread = threading.Thread(target=booth,args=(k,))   # Set up thread; target: the callable (function) to be run, args: the argument for the callable 
    new_thread.start()                                      # run the thread
```

Python使用**threading.Thread**对象来代表线程，用**threading.Lock**对象来代表一个互斥锁 (mutex)。

### 2、OOP创建线程

OOP的话，通过修改Thread类的**run()**方法来定义线程所要执行的命令。

```python
# A program to simulate selling tickets in multi-thread way
# Written by Vamei

import threading
import time
import os

# This function could be any function to do other chores.
def doChore():
    time.sleep(0.5)

# Function for each thread
class BoothThread(threading.Thread):
    def __init__(self, tid, monitor):
        self.tid          = tid
        self.monitor = monitor
        threading.Thread.__init__(self)
    def run(self):
        while True:
            monitor['lock'].acquire()                          # Lock; or wait if other thread is holding the lock
            if monitor['tick'] != 0:
                monitor['tick'] = monitor['tick'] - 1          # Sell tickets
                print(self.tid,':now left:',monitor['tick'])   # Tickets left
                doChore()                                      # Other critical operations
            else:
                print("Thread_id",self.tid," No more tickets")
                os._exit(0)                                    # Exit the whole process immediately
            monitor['lock'].release()                          # Unblock
            doChore()                                          # Non-critical operations

# Start of the main function
monitor = {'tick':100, 'lock':threading.Lock()}

# Start 10 threads
for k in range(10):
    new_thread = BoothThread(k, monitor)
    new_thread.start()
```

由于词典是**可变数据对象**，所以当它被传递给函数的时候，函数所使用的依然是同一个对象，相当于被多个线程所共享。