# 构造函数与析构函数

### 构造函数

- 构造函数不能有返回值
- 缺省构造函数时，系统将自动调用该缺省构造函数初始化对象，缺省构造函数会将所有数据成员都初始化为零或空 
- 创建一个对象时，系统自动调用构造函数



### 析构函数

- 析构函数没有参数，也没有返回值。不能重载，也就是说，一个类中只可能定义一个析构函数
- 如果一个类中没有定义析构函数，系统也会自动生成一个默认的析构函数，为空函数，什么都不做
- 调用条件：1.在函数体内定义的对象，当函数执行结束时，该对象所在类的析构函数会被自动调用；2.用new运算符动态构建的对象，在使用delete运算符释放它时。



### 拷贝构造函数

拷贝构造函数实际上也是构造函数，具有一般构造函数的所有特性，其名字也与所属类名相同。拷贝构造函数中只有一个参数，这个参数是对某个同类对象的引用。它在三种情况下被调用：

- 用类的一个已知的对象去初始化该类的另一个对象时；
- 函数的形参是类的对象，调用函数进行形参和实参的结合时；
- 函数的返回值是类的对象，函数执行完返回调用者。



### 构造函数与析构函数的调用顺序

当建立一个对象时，首先调用基类的构造函数，然后调用下一个派生类的构造函数，依次类推；而析构函数的调用顺序与此相反。

理解：

构造函数里可以调用成员变量，而继承中子类把基类的成员变为自己的成员，也就是说子类在构造函数里就可调用基类的成员，这就说明创建子类的时候必须先调用基类的构造函数。

对于析构函数，子类将基类成员变为自己的成员后，那么基类就会只存在子类中知道子类调用析构函数。假如在基类的析构函数调用比子类的先，这样会发生什么事呢？类成员终止了，而类本身却还在，但是在类存在的情况下，类成员就应该还存在的，这不就产生矛盾了吗？所以子类是调用自身的析构函数再调用基类的析构函数。



在java中，实例化一个子类的对象，首先会调用父类的**无参构造函数**。如果父类没有显式定义构造函数，那么会调用**缺省构造函数**，这个**缺省构造函数**是由编译器自动产生的。如果父类显式定义了构造函数，那么编译器就不再为父类生成缺省默认构造函数。

假设父类中定义了一个带参数的构造函数，而没有定义无参构造函数，这时候实例化一个子类的对象，就会出现编译错误，因为子类首先要调用父类的无参构造函数，但是父类没有显式定义，编译器又不为父类产生缺省构造函数。这时候可以通过在父类中显示定义无参构造函数来解决这个错误。

例题：

对文件名为Test.java的java代码描述正确的是()

```java
class Person {
    String name = "No name";
    public Person(String nm) {
        name = nm;
    }
}
class Employee extends Person {
    String empID = "0000";
    public Employee(String id) {
        empID = id;
    }
}
public class Test {
    public static void main(String args[]) {
        Employee e = new Employee("123");
        System.out.println(e.empID);
    }
}
```

A. 输出：0000

B. 输出：123

**C. 编译报错**

D. 输出：No Name



this()和super()都可以用来调用构造函数，而this()用于在同一个类内调用其他的构造函数，比如首先在Student类中定义了一个构造函数**Student(name,age)**，又另外定义了一个构造函数**Student(name,age,school)**，那么在第二个构造函数中可以通过**this(name,age)**的形式来调用第一个构造函数，**注意这里this(name,age)必须写在第二个构造函数的首行。**而super用于从子类的构造方法中调用父类的构造方法。比如父类Person有构造函数**Person(String name, int age)**，而子类有构造函数**Student(String name, int age, String school, String grade)**，那么就可以在子类构造函数中通过**super(name,age)**来调用父类构造函数。

建议：最好为每个类都显式定义无参构造函数。



参考文献：

http://www.cnblogs.com/xwdreamer/archive/2011/10/24/2296950.html



















